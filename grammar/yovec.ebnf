%import common.WS
%ignore WS

NUMBER: /-?\d+(\./d{1,4})?/
VAR_IDENT: /[A-Z]+/
YOLOL_IDENT: /[a-zA-Z][a-zA-Z0-9]*|:[a-zA-Z0-9]*/

// Statements

program: line*
line: import | export | let

import: "import" YOLOL_IDENT
export: "export" VAR_IDENT

?let: "let" VAR_IDENT "=" vector     -> letvec
    | "let" VAR_IDENT "=" range      -> letran
    | "let" VAR_IDENT "=" repeat     -> letrep
    | "let" VAR_IDENT "=" vexpr      -> letvexpr

vector: "[" (number ",")* number ("," number)* "]"
range: "range" "(" (number ",")? number (number ",")? ")"
repeat: "repeat" "(" vector count ")"

// Numbers

?num_binary_op: "+"     -> nadd
              | "-"     -> nsub
              | "*"     -> nmul
              | "/"     -> ndiv
              | "%"     -> nmod
              | "^"     -> nexp

?nexpr: nexpr num_binary_op nexpr       -> nbinary
      | "reduce" num_binary_op vexpr    -> reduce
      | vexpr "dot" vexpr               -> dot
      | vexpr "cross" vexpr             -> cross
      | "$" YOLOL_IDENT                 -> external
      | NUMBER                          -> number
      | "(" nexpr ")"

// Vectors

?vec_unary_op: "-"  -> vneg

?vec_binary_op: "+"     -> vadd
              | "-"     -> vsub

?logical_op: "<"    -> lt
           | "<="   -> le
           | ">"    -> gt
           | ">="   -> ge
           | "=="   -> eq
           | "!="   -> ne

?vexpr: "map" num_binary_op number vexpr    -> premap
     | "map" number num_binary_op vexpr     -> postmap
     | "filter" logical_op number vexpr     -> filter
     | "concat" vexpr vexpr                 -> concat
     | vec_unary_op vexpr                   -> vunary
     | vexpr vec_binary_op vexpr            -> vbinary
     | VAR_IDENT                            -> variable
     | "(" vexpr ")"
